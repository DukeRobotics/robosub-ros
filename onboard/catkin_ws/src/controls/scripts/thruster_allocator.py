#!/usr/bin/env python3

import yaml
import numpy as np

from tf.transformations import quaternion_from_euler

import controls_utils as utils


class ThrusterAllocator:
    """
    Compiles all thruster data, generating a wrench matrix that holds the force and torque of
    each thruster. Uses this matrix to calculate thruster allocations based on desired control
    effort in each degree of freedom (x, y, z, roll, pitch, yaw).

    Attributes:
        thrusters: The thrusters that are part of the robot.
        wrenchmat: A 6xT matrix with column vectors equal to the force and torque of each thruster
        wrenchmat_pinv: A Tx6 matrix that is used to solve for thruster allocations
    """

    def __init__(self):
        """
        Retrieves thruster data from a yaml config file, computes their forces and torques along all six axes,
        constructs wrench matrix, and computes Moore-Penrose inverse of wrench matrix.
        """

        # Retrieve thruster data from yaml config file
        thrusters_config_filename = utils.get_config_file(utils.ConfigFileType.THRUSTERS)
        with open(thrusters_config_filename) as f:
            vehicle = yaml.safe_load(f)

        # Loop over each thruster, calculating its force and torque vectors, and adding them to the wrench matrix
        # Negates force and torque vectors if thruster is flipped
        self.wrenchmat = np.empty((6, len(self.thrusters)))
        for index, thruster in enumerate(vehicle['thrusters']):
            force_hat, torque = self.calc_thruster_force_hat_torque(
                thruster['pos'],
                thruster['rpy']
            )

            self.wrenchmat[0][index] = force_hat[0]
            self.wrenchmat[1][index] = force_hat[1]
            self.wrenchmat[2][index] = force_hat[2]
            self.wrenchmat[3][index] = torque[0]
            self.wrenchmat[4][index] = torque[1]
            self.wrenchmat[5][index] = torque[2]

            self.wrenchmat[:index] *= -1 if thruster['flipped'] else 1

        # Calculate Moore-Penrose inverse of wrench matrix
        self.wrenchmat_pinv = np.linalg.pinv(self.wrenchmat)

    def calc_thruster_force_hat_torque(self, pos, rpy):
        """
        Describes a thruster in terms of position and orientation. Calculates the
        force and torque that the thruster applies when spun.

        Args:
            pos: The x, y, z position of the thruster (m) relative to the robot's center of mass
            rpy: The euler angle orientation of the thruster (degrees) relative to the robot's frame of reference

        Returns:
            Tuple (force_hat, torque)
            force_hat: The unit norm force vector applied by the thruster in x, y, z
            torque: The torque vector applied by the thruster
        """

        # Quaternion from Euler rpy
        q = quaternion_from_euler(np.deg2rad(rpy[0]), np.deg2rad(rpy[1]), np.deg2rad(rpy[2]), 'sxyz')
        # sxyz denotes a static (extrinsic) frame of reference.
        # https://github.com/matthew-brett/transforms3d/blob/master/transforms3d/euler.py
        # https://en.wikipedia.org/wiki/Euler_angles

        # Unit vector representing force of thruster in x,y,z directions
        force_hat = utils.quat_vec_mult(q, [1, 0, 0])
        torque = np.cross(pos, force_hat)  # vector representing torque generated from thruster
        return (force_hat, torque)

    def calc_t_allocs(self, pid_wrench):
        """Calculates thruster allocations given wrench matrix and desired control effort in each
        DOF. Explanation of the math (everything is in terms of a local frame of reference):

        Let the desired control efforts in each DOF be a 6x1 vector p. A Tx6 wrench matrix W (where T is the number of
        thrusters) can be constructed such that each of its column vectors holds the force and torque generated by a
        given thruster. To solve for the thruster allocations x, we need to solve the equation p = Wx. We can multiply
        both sides by the Moore-Penrose pseudo-inverse of W (W_inv), yielding W_inv*p = x.

        Args:
            pid_wrench: The 6x1 vector holding control efforts for x, y, z, roll, pitch, yaw

        Returns:
            A Tx1 vector holding relative thruster allocations to exert the desired control effort
        """
        t_allocs = np.matmul(self.wrenchmat_pinv, pid_wrench)

        max_pow = np.max(np.abs(t_allocs))
        if max_pow > 1:
            t_allocs /= max_pow

        return t_allocs
