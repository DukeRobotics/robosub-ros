require "math"

function sysCall_init()
    h=sim.getObjectAssociatedWithScript(sim.handle_self)
    print(1)
    --moveSub=simROS.subscribe('/move', 'geometry_msgs/Point', 'move_callback')
    print(2)
    m=sim.getShapeMassAndInertia(h)
    print(3)
    waterlevel = 0
    p = 1000
    dragcoef = 1.1
    globforce = {0,0,0}
    print(p)
end

function sysCall_actuation()
    -- put your actuation code here
    --
    -- For example:
    --
    -- local position=sim.getObjectPosition(handle,-1)
    -- position[1]=position[1]+0.001
    -- sim.setObjectPosition(handle,-1,position)
    --[[
    waterlevel = 0  
    print(waterlevel)
    p = 1000
    dragcoef = 1.1
    m=sim.getShapeMassAndInertia(h)
    globforce = {0,0,0}
    --]]

    pos = sim.getObjectPosition(h, -1)
    --print(pos[3])
    res, xsizemin = sim.getObjectFloatParameter(h, 15)
    res, ysizemin = sim.getObjectFloatParameter(h, 16)
    res, zsizemin = sim.getObjectFloatParameter(h, 17)
    res, xsizemax = sim.getObjectFloatParameter(h, 18)
    res, ysizemax = sim.getObjectFloatParameter(h, 19)
    res, zsizemax = sim.getObjectFloatParameter(h, 20)
    xsize = xsizemax-xsizemin
    ysize = ysizemax-ysizemin
    zsize = zsizemax-zsizemin
    --print(zsize)
    grav=sim.getArrayParameter(sim.arrayparam_gravity)
    fbuoy = xsize*ysize
    if zsize<=(waterlevel-pos[3]) then
        subdepth = zsize
    else
        subdepth = (waterlevel-pos[3])
        --print('hi')
    end
    fbuoy = fbuoy*subdepth*(-1)*grav[3]*p
    if pos[3]>waterlevel then 
        fbuoy = 0 
        subdepth = 0
    end
    
    v=sim.getVelocity(h)
    dragforce={0,0,0}
    dragforce[3] = -p*v[3]*dragcoef*xsize*ysize
    if pos[3]>(waterlevel-zsize) and v[3]>0 then dragforce[3]=0 end
    if pos[3]>waterlevel then dragforce[3]=0 end
    --print(pos[3], fbuoy, globforce, dragforce, grav[3]*m)
    dragforce[2] = -p*v[2]*dragcoef*xsize*subdepth
    dragforce[1] = -p*v[1]*dragcoef*ysize*subdepth
    sim.addForceAndTorque(h, {globforce[1]+dragforce[1],
                              globforce[2]+dragforce[2],
                              globforce[3]+fbuoy+dragforce[3]})
end

function move_callback(msg)
    fudge = m/20
    globforce[1] = msg['x']*fudge
    globforce[2] = msg['y']*fudge
    globforce[3] = msg['z']*fudge
end

function sysCall_sensing()
    -- put your sensing code here
end

function sysCall_cleanup()
    -- do some clean-up here
end

--[[
function sysCall_init()
    h=sim.getObjectAssociatedWithScript(sim.handle_self)
    m=sim.getShapeMassAndInertia(h)
    local r,dmin=sim.getObjectFloatParameter(h,sim.objfloatparam_objbbox_min_z)
    local r,dmax=sim.getObjectFloatParameter(h,sim.objfloatparam_objbbox_max_z)
    radius=(dmax-dmin)*0.5
    waterLevel=0 -- water at z-coordinate 0
    dragCoeff=3
end

function sysCall_actuation()
    local p=sim.getObjectPosition(h,-1)
    local t=(waterLevel-p[3]+radius)/(1*radius)
    if t<0 then t=0 end
    if t>2 then t=2 end
    local accel=sim.getArrayParameter(sim.arrayparam_gravity)
    local v=sim.getVelocity(h)
    sim.addForceAndTorque(h,{-accel[1]*m*t-v[1]*dragCoeff,-accel[2]*m*t-v[2]*dragCoeff,-accel[3]*m*t-v[3]*dragCoeff})
end
--]]

-- You can define additional system calls here:
--[[
function sysCall_suspend()
end

function sysCall_resume()
end

function sysCall_dynCallback(inData)
end

function sysCall_jointCallback(inData)
    return outData
end

function sysCall_contactCallback(inData)
    return outData
end

function sysCall_beforeCopy(inData)
    for key,value in pairs(inData.objectHandles) do
        print("Object with handle "..key.." will be copied")
    end
end

function sysCall_afterCopy(inData)
    for key,value in pairs(inData.objectHandles) do
        print("Object with handle "..key.." was copied")
    end
end

function sysCall_beforeDelete(inData)
    for key,value in pairs(inData.objectHandles) do
        print("Object with handle "..key.." will be deleted")
    end
    -- inData.allObjects indicates if all objects in the scene will be deleted
end

function sysCall_afterDelete(inData)
    for key,value in pairs(inData.objectHandles) do
        print("Object with handle "..key.." was deleted")
    end
    -- inData.allObjects indicates if all objects in the scene were deleted
end

function sysCall_afterCreate(inData)
    for key,value in pairs(inData.objectHandles) do
        print("Object with handle "..value.." was created")
    end
end
--]]
